#!/bin/bash

# Claude Cascade Template Validator
# Advanced validation for planning templates and workflow integrity

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CASCADE_ROOT="$(dirname "$SCRIPT_DIR")"
VERBOSE=0
STRICT_MODE=0
OUTPUT_FORMAT="text"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Validation statistics
VALIDATIONS_RUN=0
VALIDATIONS_PASSED=0
VALIDATIONS_FAILED=0
WARNINGS_COUNT=0

# Usage information
usage() {
    cat << EOF
Claude Cascade Template Validator

USAGE:
    claude-cascade-validate [OPTIONS] <file_or_directory>

OPTIONS:
    -v, --verbose       Enable verbose output
    -s, --strict        Enable strict validation mode
    -f, --format FORMAT Output format: text, json, yaml (default: text)
    -h, --help          Show this help message
    --security          Run security validation checks
    --structure         Validate template structure only
    --content           Validate content completeness
    --examples          Validate example workflows
    --all               Run all validation checks (default)

EXAMPLES:
    claude-cascade-validate templates/frontend.md     # Validate specific template
    claude-cascade-validate templates/                # Validate all templates
    claude-cascade-validate --strict examples/        # Strict validation of examples
    claude-cascade-validate --format json template.md # JSON output format

VALIDATION CHECKS:
    Structure          - Required sections and formatting
    Content            - Completeness and quality
    Security           - Safety and input validation
    Examples           - Working example validation
    Links              - Reference and link verification
    Syntax             - Markdown and YAML syntax

EOF
}

# Logging functions
log() {
    if [[ $OUTPUT_FORMAT == "text" ]]; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_success() {
    if [[ $OUTPUT_FORMAT == "text" ]]; then
        echo -e "${GREEN}[PASS]${NC} $1"
    fi
}

log_error() {
    if [[ $OUTPUT_FORMAT == "text" ]]; then
        echo -e "${RED}[FAIL]${NC} $1" >&2
    fi
}

log_warning() {
    if [[ $OUTPUT_FORMAT == "text" ]]; then
        echo -e "${YELLOW}[WARN]${NC} $1"
    fi
    WARNINGS_COUNT=$((WARNINGS_COUNT + 1))
}

log_verbose() {
    if [[ $VERBOSE -eq 1 && $OUTPUT_FORMAT == "text" ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $1"
    fi
}

# Validation result tracking
add_validation() {
    VALIDATIONS_RUN=$((VALIDATIONS_RUN + 1))
    if [[ $1 -eq 0 ]]; then
        VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
    else
        VALIDATIONS_FAILED=$((VALIDATIONS_FAILED + 1))
    fi
}

# Template structure validation
validate_template_structure() {
    local file="$1"
    local errors=0
    
    log_verbose "Validating structure of $file"
    
    # Required sections for planning templates
    local required_sections=(
        "# Pre-Execution Plan"
        "## Objective"
        "## Detailed Steps"
        "## Success Criteria"
        "## Resources Required"
        "## Risks & Mitigation"
        "## Expected Outcomes"
        "## Verification Tests Planned"
        "## Definition of Done"
    )
    
    for section in "${required_sections[@]}"; do
        if ! grep -q "^$section" "$file"; then
            log_error "Missing required section: $section in $file"
            errors=$((errors + 1))
        fi
    done
    
    # Check for YAML frontmatter
    if ! head -n 5 "$file" | grep -q "^---"; then
        if [[ $STRICT_MODE -eq 1 ]]; then
            log_error "Missing YAML frontmatter in $file"
            errors=$((errors + 1))
        else
            log_warning "No YAML frontmatter found in $file"
        fi
    fi
    
    # Check for proper markdown syntax
    if command -v markdownlint >/dev/null 2>&1; then
        if ! markdownlint "$file" >/dev/null 2>&1; then
            log_warning "Markdown syntax issues in $file"
        fi
    fi
    
    add_validation $errors
    return $errors
}

# Content completeness validation
validate_content_completeness() {
    local file="$1"
    local errors=0
    
    log_verbose "Validating content completeness of $file"
    
    # Check for placeholder content
    local placeholders=(
        "TODO"
        "PLACEHOLDER"
        "FILL_IN"
        "TBD"
        "XXX"
    )
    
    for placeholder in "${placeholders[@]}"; do
        if grep -qi "$placeholder" "$file"; then
            if [[ $STRICT_MODE -eq 1 ]]; then
                log_error "Placeholder content found ($placeholder) in $file"
                errors=$((errors + 1))
            else
                log_warning "Placeholder content found ($placeholder) in $file"
            fi
        fi
    done
    
    # Check for minimum content in key sections
    if ! grep -A 3 "## Objective" "$file" | grep -q "[a-zA-Z].*[a-zA-Z].*[a-zA-Z]"; then
        log_error "Objective section appears incomplete in $file"
        errors=$((errors + 1))
    fi
    
    if ! grep -A 5 "## Success Criteria" "$file" | grep -q "\- \[ \]"; then
        log_error "Success criteria should include checkboxes in $file"
        errors=$((errors + 1))
    fi
    
    # Check for realistic time estimates
    if grep -qi "duration.*hour" "$file"; then
        local duration=$(grep -i "duration.*hour" "$file" | head -1)
        if [[ $duration =~ ([0-9]+) ]]; then
            local hours=${BASH_REMATCH[1]}
            if [[ $hours -gt 160 ]]; then # More than a month
                log_warning "Unusually long duration estimate ($hours hours) in $file"
            elif [[ $hours -lt 1 ]]; then
                log_warning "Very short duration estimate ($hours hours) in $file"
            fi
        fi
    fi
    
    add_validation $errors
    return $errors
}

# Security validation
validate_security() {
    local file="$1"
    local errors=0
    
    log_verbose "Validating security of $file"
    
    # Check for potentially dangerous commands
    local dangerous_patterns=(
        "rm -rf"
        "sudo rm"
        "eval"
        "exec"
        "system("
        "\$\(.*\)"
        "`.*`"
    )
    
    for pattern in "${dangerous_patterns[@]}"; do
        if grep -q "$pattern" "$file"; then
            log_error "Potentially dangerous command found: $pattern in $file"
            errors=$((errors + 1))
        fi
    done
    
    # Check for hardcoded secrets or sensitive information
    local secret_patterns=(
        "password.*=.*['\"].*['\"]"
        "api_key.*=.*['\"].*['\"]"
        "secret.*=.*['\"].*['\"]"
        "token.*=.*['\"].*['\"]"
        "ssh-rsa"
        "BEGIN PRIVATE KEY"
    )
    
    for pattern in "${secret_patterns[@]}"; do
        if grep -qi "$pattern" "$file"; then
            log_error "Potential hardcoded secret found in $file"
            errors=$((errors + 1))
        fi
    done
    
    # Check for unsafe URL patterns
    if grep -q "http://.*password\|http://.*token\|http://.*secret" "$file"; then
        log_error "Unsafe URL with credentials found in $file"
        errors=$((errors + 1))
    fi
    
    add_validation $errors
    return $errors
}

# Example workflow validation
validate_examples() {
    local file="$1"
    local errors=0
    
    log_verbose "Validating examples in $file"
    
    # Check for code blocks with examples
    local code_blocks=$(grep -c "^```" "$file" || true)
    if [[ $code_blocks -gt 0 && $((code_blocks % 2)) -ne 0 ]]; then
        log_error "Unmatched code block markers in $file"
        errors=$((errors + 1))
    fi
    
    # Validate shell commands in code blocks
    local in_shell_block=0
    while IFS= read -r line; do
        if [[ $line =~ ^\`\`\`(bash|sh|shell) ]]; then
            in_shell_block=1
        elif [[ $line =~ ^\`\`\` && $in_shell_block -eq 1 ]]; then
            in_shell_block=0
        elif [[ $in_shell_block -eq 1 ]]; then
            # Basic shell syntax check
            if [[ $line =~ ^[a-zA-Z] ]] && ! bash -n <(echo "$line") 2>/dev/null; then
                log_warning "Potential shell syntax error: $line in $file"
            fi
        fi
    done < "$file"
    
    # Check for realistic example data
    if grep -q "example\.com\|test\.test\|localhost" "$file"; then
        log_verbose "Found example domains/URLs (good practice)"
    fi
    
    add_validation $errors
    return $errors
}

# Link validation
validate_links() {
    local file="$1"
    local errors=0
    
    log_verbose "Validating links in $file"
    
    # Extract markdown links
    local links=$(grep -o '\[.*\]([^)]*)' "$file" | sed 's/.*(\([^)]*\)).*/\1/' || true)
    
    while IFS= read -r link; do
        [[ -z "$link" ]] && continue
        
        if [[ $link =~ ^https?:// ]]; then
            # External link - basic format validation
            if ! [[ $link =~ ^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/.*)?$ ]]; then
                log_warning "Malformed URL: $link in $file"
            fi
        elif [[ $link =~ ^/ ]]; then
            # Absolute path
            if [[ ! -f "$CASCADE_ROOT$link" ]]; then
                log_error "Broken internal link: $link in $file"
                errors=$((errors + 1))
            fi
        elif [[ $link =~ ^[^/] ]]; then
            # Relative path
            local file_dir=$(dirname "$file")
            if [[ ! -f "$file_dir/$link" ]]; then
                log_error "Broken relative link: $link in $file"
                errors=$((errors + 1))
            fi
        fi
    done <<< "$links"
    
    add_validation $errors
    return $errors
}

# Syntax validation
validate_syntax() {
    local file="$1"
    local errors=0
    
    log_verbose "Validating syntax of $file"
    
    # Check file encoding
    if ! file "$file" | grep -q "UTF-8\|ASCII"; then
        log_warning "File encoding may not be UTF-8: $file"
    fi
    
    # Check for YAML frontmatter syntax
    if head -n 1 "$file" | grep -q "^---"; then
        local yaml_end=$(grep -n "^---" "$file" | sed -n '2p' | cut -d: -f1)
        if [[ -n $yaml_end ]]; then
            local yaml_content=$(sed -n "2,$((yaml_end-1))p" "$file")
            if command -v yq >/dev/null 2>&1; then
                if ! echo "$yaml_content" | yq . >/dev/null 2>&1; then
                    log_error "Invalid YAML frontmatter in $file"
                    errors=$((errors + 1))
                fi
            fi
        fi
    fi
    
    # Check for common markdown syntax errors
    local line_number=0
    while IFS= read -r line; do
        line_number=$((line_number + 1))
        
        # Check for unmatched brackets
        local open_brackets=$(echo "$line" | grep -o '\[' | wc -l)
        local close_brackets=$(echo "$line" | grep -o '\]' | wc -l)
        if [[ $open_brackets -ne $close_brackets ]]; then
            log_warning "Unmatched brackets on line $line_number in $file"
        fi
        
        # Check for unmatched parentheses in links
        if [[ $line =~ \[.*\]\( ]]; then
            local open_parens=$(echo "$line" | grep -o '(' | wc -l)
            local close_parens=$(echo "$line" | grep -o ')' | wc -l)
            if [[ $open_parens -ne $close_parens ]]; then
                log_warning "Unmatched parentheses in links on line $line_number in $file"
            fi
        fi
    done < "$file"
    
    add_validation $errors
    return $errors
}

# Validate a single file
validate_file() {
    local file="$1"
    local total_errors=0
    
    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        return 1
    fi
    
    if [[ ! -r "$file" ]]; then
        log_error "File not readable: $file"
        return 1
    fi
    
    log "Validating: $file"
    
    # Run structure validation
    validate_template_structure "$file"
    total_errors=$((total_errors + $?))
    
    # Run content validation
    validate_content_completeness "$file"
    total_errors=$((total_errors + $?))
    
    # Run security validation
    validate_security "$file"
    total_errors=$((total_errors + $?))
    
    # Run example validation
    validate_examples "$file"
    total_errors=$((total_errors + $?))
    
    # Run link validation
    validate_links "$file"
    total_errors=$((total_errors + $?))
    
    # Run syntax validation
    validate_syntax "$file"
    total_errors=$((total_errors + $?))
    
    if [[ $total_errors -eq 0 ]]; then
        log_success "Validation passed: $file"
    else
        log_error "Validation failed: $file ($total_errors errors)"
    fi
    
    return $total_errors
}

# Validate directory recursively
validate_directory() {
    local dir="$1"
    local total_errors=0
    
    if [[ ! -d "$dir" ]]; then
        log_error "Directory not found: $dir"
        return 1
    fi
    
    log "Validating directory: $dir"
    
    # Find all markdown files
    while IFS= read -r -d '' file; do
        validate_file "$file"
        total_errors=$((total_errors + $?))
    done < <(find "$dir" -name "*.md" -type f -print0)
    
    return $total_errors
}

# Output results in different formats
output_results() {
    local format="$1"
    local exit_code="$2"
    
    case $format in
        "json")
            cat << EOF
{
  "validation_summary": {
    "total_validations": $VALIDATIONS_RUN,
    "passed": $VALIDATIONS_PASSED,
    "failed": $VALIDATIONS_FAILED,
    "warnings": $WARNINGS_COUNT,
    "success": $([ $exit_code -eq 0 ] && echo "true" || echo "false")
  }
}
EOF
            ;;
        "yaml")
            cat << EOF
validation_summary:
  total_validations: $VALIDATIONS_RUN
  passed: $VALIDATIONS_PASSED
  failed: $VALIDATIONS_FAILED
  warnings: $WARNINGS_COUNT
  success: $([ $exit_code -eq 0 ] && echo "true" || echo "false")
EOF
            ;;
        "text"|*)
            echo
            echo "=================================="
            echo "Validation Results Summary"
            echo "=================================="
            echo "Total Validations: $VALIDATIONS_RUN"
            echo "Passed: $VALIDATIONS_PASSED"
            echo "Failed: $VALIDATIONS_FAILED"
            echo "Warnings: $WARNINGS_COUNT"
            echo
            if [[ $exit_code -eq 0 ]]; then
                log_success "All validations passed!"
            else
                log_error "Some validations failed."
            fi
            ;;
    esac
}

# Main function
main() {
    local target=""
    local run_structure=1
    local run_content=1
    local run_security=1
    local run_examples=1
    local run_links=1
    local run_syntax=1
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -s|--strict)
                STRICT_MODE=1
                shift
                ;;
            -f|--format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            --security)
                run_structure=0
                run_content=0
                run_examples=0
                run_links=0
                run_syntax=0
                shift
                ;;
            --structure)
                run_content=0
                run_security=0
                run_examples=0
                run_links=0
                run_syntax=0
                shift
                ;;
            --content)
                run_structure=0
                run_security=0
                run_examples=0
                run_links=0
                run_syntax=0
                shift
                ;;
            --examples)
                run_structure=0
                run_content=0
                run_security=0
                run_links=0
                run_syntax=0
                shift
                ;;
            --all)
                # All checks enabled by default
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                usage
                exit 1
                ;;
            *)
                target="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$target" ]]; then
        echo "Error: No file or directory specified" >&2
        usage
        exit 1
    fi
    
    if [[ ! -e "$target" ]]; then
        echo "Error: File or directory not found: $target" >&2
        exit 1
    fi
    
    log "Starting Claude Cascade validation..."
    log_verbose "Target: $target"
    log_verbose "Strict mode: $([ $STRICT_MODE -eq 1 ] && echo "enabled" || echo "disabled")"
    log_verbose "Output format: $OUTPUT_FORMAT"
    
    local exit_code=0
    
    if [[ -f "$target" ]]; then
        validate_file "$target"
        exit_code=$?
    elif [[ -d "$target" ]]; then
        validate_directory "$target"
        exit_code=$?
    fi
    
    output_results "$OUTPUT_FORMAT" $exit_code
    exit $exit_code
}

# Check if script is being sourced or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi