// Generated by Claude on 2025-08-16 for: User Profile Editing Example
import { useState, useCallback } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';

interface ProfileUpdateData {
  name: string;
  bio?: string;
  avatar?: File;
  forceUpdate?: boolean;
}

interface ProfileUpdateResponse {
  success: boolean;
  data?: {
    id: string;
    name: string;
    bio?: string;
    avatarUrl?: string;
    updatedAt: string;
  };
  conflict?: {
    message: string;
    serverData: any;
    timestamp: string;
  };
  error?: string;
}

interface UseProfileUpdateOptions {
  onSuccess?: (data: ProfileUpdateResponse['data']) => void;
  onError?: (error: Error) => void;
}

interface UseProfileUpdateReturn {
  updateProfile: (data: ProfileUpdateData) => Promise<void>;
  isLoading: boolean;
  error: Error | null;
  clearError: () => void;
}

// Utility function to convert File to base64 for chunked upload
const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const result = reader.result as string;
      resolve(result.split(',')[1]); // Remove data:image/xxx;base64, prefix
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

// Image compression using Web Worker
const compressImage = async (file: File): Promise<File> => {
  return new Promise((resolve, reject) => {
    // Create Web Worker for image compression
    const worker = new Worker(
      new URL('../workers/imageCompression.worker.ts', import.meta.url)
    );

    worker.postMessage({
      file,
      maxWidth: 800,
      maxHeight: 800,
      quality: 0.8,
    });

    worker.onmessage = (event) => {
      const { compressedFile, error } = event.data;
      worker.terminate();
      
      if (error) {
        reject(new Error(error));
      } else {
        resolve(compressedFile);
      }
    };

    worker.onerror = (error) => {
      worker.terminate();
      reject(error);
    };

    // Timeout after 10 seconds
    setTimeout(() => {
      worker.terminate();
      reject(new Error('Image compression timeout'));
    }, 10000);
  });
};

// API function to update profile
const updateProfileAPI = async (data: ProfileUpdateData): Promise<ProfileUpdateResponse> => {
  const formData = new FormData();
  formData.append('name', data.name);
  
  if (data.bio) {
    formData.append('bio', data.bio);
  }
  
  if (data.avatar) {
    // Compress image before upload
    const compressedAvatar = await compressImage(data.avatar);
    formData.append('avatar', compressedAvatar);
  }
  
  if (data.forceUpdate) {
    formData.append('forceUpdate', 'true');
  }

  // Get CSRF token from meta tag
  const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
  
  const headers: HeadersInit = {};
  if (csrfToken) {
    headers['X-CSRF-Token'] = csrfToken;
  }

  const response = await fetch('/api/user/profile', {
    method: 'PUT',
    headers,
    body: formData,
    credentials: 'include',
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
  }

  return response.json();
};

export const useProfileUpdate = (options: UseProfileUpdateOptions = {}): UseProfileUpdateReturn => {
  const [error, setError] = useState<Error | null>(null);
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: updateProfileAPI,
    onSuccess: (data) => {
      // Update cached profile data
      queryClient.setQueryData(['profile'], data.data);
      
      // Clear any previous errors
      setError(null);
      
      // Call success callback
      options.onSuccess?.(data.data);
    },
    onError: (error: Error) => {
      setError(error);
      options.onError?.(error);
    },
    // Optimistic updates
    onMutate: async (newData) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['profile'] });

      // Snapshot previous value
      const previousProfile = queryClient.getQueryData(['profile']);

      // Optimistically update to new value
      queryClient.setQueryData(['profile'], (old: any) => ({
        ...old,
        name: newData.name,
        bio: newData.bio,
        // Don't optimistically update avatar since it needs processing
      }));

      // Return context object with snapshot
      return { previousProfile };
    },
    // Rollback on error
    onError: (error, newData, context) => {
      if (context?.previousProfile) {
        queryClient.setQueryData(['profile'], context.previousProfile);
      }
      setError(error);
      options.onError?.(error);
    },
  });

  const updateProfile = useCallback(async (data: ProfileUpdateData) => {
    try {
      await mutation.mutateAsync(data);
    } catch (error) {
      // Error is already handled by mutation.onError
      throw error;
    }
  }, [mutation]);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    updateProfile,
    isLoading: mutation.isPending,
    error,
    clearError,
  };
};

export default useProfileUpdate;